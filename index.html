<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>PPG Prototype (Camera)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; padding: 18px; }
    .card { max-width: 720px; margin: 0 auto; }
    h1 { font-size: 22px; margin: 0 0 10px; }
    p { margin: 10px 0; line-height: 1.35; }
    .small { font-size: 13px; opacity: 0.85; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; }
    button.primary { background: #0ea5e9; color: white; }
    button.secondary { background: #e5e7eb; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; background: #f3f4f6; border-radius: 999px; }
    .dot { width: 10px; height: 10px; border-radius: 999px; background: #9ca3af; display: inline-block; }
    .dot.ok { background: #22c55e; }
    .dot.warn { background: #f59e0b; }
    .dot.bad { background: #ef4444; }
    .big { font-size: 42px; font-weight: 700; letter-spacing: -0.5px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 640px) { .grid { grid-template-columns: 1fr 1fr; } }
    canvas { width: 100%; height: 140px; background: #0b1220; border-radius: 12px; }
    video { display: none; }
    code { background: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Finger camera pulse prototype</h1>

    <p class="small">
      Prototype only. Not a medical device. Values will wobble if the signal is noisy.
    </p>

    <div class="row">
      <button id="startBtn" class="primary">Start camera</button>
      <button id="stopBtn" class="secondary" disabled>Stop</button>
      <button id="torchBtn" class="secondary" disabled>Try torch</button>
      <span class="pill"><span id="sigDot" class="dot"></span><span id="sigText">signal: waiting</span></span>
    </div>

    <div class="grid">
      <div>
        <div class="small">Heart rate</div>
        <div class="big"><span id="hrVal">--</span> <span class="small">bpm</span></div>
        <div class="small">Peaks (recent): <span id="peakCount">0</span></div>
      </div>
      <div>
        <div class="small">Tips</div>
        <p class="small">
          Use the rear camera. Cover lens fully with fingertip. Press gently, keep still.
          If you can, use brighter ambient light. Torch may work on some Android phones.
        </p>
      </div>
    </div>

    <p class="small">Waveform (green channel)</p>
    <canvas id="plot" width="900" height="220"></canvas>

    <video id="video" playsinline></video>
    <canvas id="frame" width="160" height="120" style="display:none;"></canvas>

    <p class="small">
      If iPhone asks again: camera permissions only work on HTTPS and usually prefer a normal tab (not inside an iframe).
    </p>
  </div>

<script>
(() => {
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const torchBtn = document.getElementById('torchBtn');
  const hrVal    = document.getElementById('hrVal');
  const peakCountEl = document.getElementById('peakCount');

  const sigDot  = document.getElementById('sigDot');
  const sigText = document.getElementById('sigText');

  const video = document.getElementById('video');
  const frameCanvas = document.getElementById('frame');
  const frameCtx = frameCanvas.getContext('2d', { willReadFrequently: true });

  const plot = document.getElementById('plot');
  const pctx = plot.getContext('2d');

  let stream = null;
  let track = null;
  let rafId = null;

  // Signal buffers
  const fsTarget = 30; // target-ish sample rate
  const bufLen = 10 * fsTarget; // last 10 seconds
  const sig = new Float32Array(bufLen);
  let idx = 0;

  // For peak detection
  const peakTimes = []; // ms timestamps for peaks
  let lastPeakT = 0;
  let lastAbove = false;

  // Simple running stats
  function meanStd(arr) {
    let m = 0;
    for (let i = 0; i < arr.length; i++) m += arr[i];
    m /= arr.length;
    let v = 0;
    for (let i = 0; i < arr.length; i++) {
      const d = arr[i] - m;
      v += d * d;
    }
    v /= arr.length;
    return { mean: m, std: Math.sqrt(v) };
  }

  function setSignalStatus(level, text) {
    sigDot.className = 'dot ' + level;
    sigText.textContent = text;
  }

  function drawPlot() {
    pctx.clearRect(0, 0, plot.width, plot.height);

    // Background
    pctx.fillStyle = '#0b1220';
    pctx.fillRect(0, 0, plot.width, plot.height);

    // Grab ordered view of signal
    const ordered = new Float32Array(bufLen);
    for (let i = 0; i < bufLen; i++) {
      ordered[i] = sig[(idx + i) % bufLen];
    }

    // Detrend for display: subtract mean
    const { mean, std } = meanStd(ordered);
    const scale = std > 1e-6 ? (0.42 * plot.height / std) : 1;

    // Draw center line
    pctx.strokeStyle = 'rgba(255,255,255,0.12)';
    pctx.beginPath();
    pctx.moveTo(0, plot.height * 0.5);
    pctx.lineTo(plot.width, plot.height * 0.5);
    pctx.stroke();

    // Waveform
    pctx.strokeStyle = 'rgba(34,197,94,0.95)';
    pctx.lineWidth = 2;
    pctx.beginPath();
    for (let x = 0; x < plot.width; x++) {
      const i = Math.floor(x * (bufLen - 1) / (plot.width - 1));
      const y = (plot.height * 0.5) - ((ordered[i] - mean) * scale);
      if (x === 0) pctx.moveTo(x, y);
      else pctx.lineTo(x, y);
    }
    pctx.stroke();
  }

  function estimateHR() {
    // Use last 8 seconds of peaks
    const now = performance.now();
    const windowMs = 8000;
    const recent = peakTimes.filter(t => (now - t) <= windowMs);

    peakCountEl.textContent = String(recent.length);

    if (recent.length < 2) {
      hrVal.textContent = '--';
      return;
    }

    // Compute IBI median
    const ibis = [];
    for (let i = 1; i < recent.length; i++) {
      ibis.push(recent[i] - recent[i - 1]);
    }

    // Reject implausible IBIs (30 to 200 bpm)
    const filtered = ibis.filter(ms => ms >= 300 && ms <= 2000);
    if (filtered.length < 2) {
      hrVal.textContent = '--';
      return;
    }

    filtered.sort((a,b) => a-b);
    const mid = Math.floor(filtered.length / 2);
    const median = filtered.length % 2 ? filtered[mid] : (filtered[mid - 1] + filtered[mid]) / 2;

    const bpm = 60000 / median;
    hrVal.textContent = String(Math.round(bpm));
  }

  function computeFingerPresence(frameData) {
    // frameData: Uint8ClampedArray RGBA
    // We use mean brightness and "redness" ratio to guess fingertip cover.
    let r = 0, g = 0, b = 0;
    const n = frameData.length / 4;
    for (let i = 0; i < frameData.length; i += 4) {
      r += frameData[i];
      g += frameData[i + 1];
      b += frameData[i + 2];
    }
    r /= n; g /= n; b /= n;

    const brightness = (r + g + b) / 3;
    const redness = r / (g + b + 1e-6);
    return { r, g, b, brightness, redness };
  }

  function pushSample(v) {
    sig[idx] = v;
    idx = (idx + 1) % bufLen;
  }

  function detectPeaks() {
    // Use recent portion of ordered signal
    const ordered = new Float32Array(bufLen);
    for (let i = 0; i < bufLen; i++) ordered[i] = sig[(idx + i) % bufLen];

    // Consider last ~3 seconds for thresholding
    const N = Math.min(bufLen, Math.floor(3 * fsTarget));
    const tail = ordered.subarray(bufLen - N);
    const { mean, std } = meanStd(tail);

    // Dynamic threshold
    const thr = mean + 0.6 * std;

    // Evaluate current sample (most recent)
    const cur = ordered[bufLen - 1];
    const now = performance.now();

    // Basic refractory: 300ms
    const refractoryMs = 300;

    const above = cur > thr;

    if (!lastAbove && above && (now - lastPeakT) > refractoryMs) {
      // rising edge crossing threshold = peak-ish marker
      peakTimes.push(now);
      lastPeakT = now;

      // Keep peaks in last 20s
      const keepMs = 20000;
      while (peakTimes.length && (now - peakTimes[0]) > keepMs) peakTimes.shift();
    }

    lastAbove = above;
  }

  async function tryTorch(on) {
    if (!track) return false;
    try {
      // Not supported on many iPhones. Often works on Android Chrome.
      await track.applyConstraints({ advanced: [{ torch: !!on }] });
      return true;
    } catch (e) {
      return false;
    }
  }

  async function start() {
    startBtn.disabled = true;
    setSignalStatus('', 'signal: startingâ€¦');

    try {
      stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 640 },
          height: { ideal: 480 }
        }
      });

      video.srcObject = stream;
      await video.play();

      track = stream.getVideoTracks()[0];

      stopBtn.disabled = false;
      torchBtn.disabled = false;

      setSignalStatus('warn', 'signal: place finger on camera');

      loop();
    } catch (err) {
      console.error(err);
      setSignalStatus('bad', 'signal: camera blocked');
      startBtn.disabled = false;
      alert('Camera permission failed. Open this page in a normal browser tab (not inside an embedded frame) and allow camera access.');
    }
  }

  function stop() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;

    if (stream) {
      stream.getTracks().forEach(t => t.stop());
    }
    stream = null;
    track = null;

    startBtn.disabled = false;
    stopBtn.disabled = true;
    torchBtn.disabled = true;

    hrVal.textContent = '--';
    peakCountEl.textContent = '0';
    setSignalStatus('', 'signal: stopped');
  }

  function loop() {
    // Sample one frame
    const w = frameCanvas.width, h = frameCanvas.height;

    frameCtx.drawImage(video, 0, 0, w, h);
    const img = frameCtx.getImageData(0, 0, w, h);
    const { brightness, redness, g } = computeFingerPresence(img.data);

    // Use mean green as raw PPG sample
    pushSample(g);

    // Finger heuristics
    // These are intentionally loose.
    const fingerLikely = (brightness < 160) && (redness > 0.95);

    // Signal quality heuristic: variability in last 3s
    const ordered = new Float32Array(bufLen);
    for (let i = 0; i < bufLen; i++) ordered[i] = sig[(idx + i) % bufLen];
    const N = Math.min(bufLen, Math.floor(3 * fsTarget));
    const tail = ordered.subarray(bufLen - N);
    const { std } = meanStd(tail);

    if (!fingerLikely) {
      setSignalStatus('warn', 'signal: cover camera with finger');
    } else if (std < 0.7) {
      setSignalStatus('warn', 'signal: too flat, adjust pressure/light');
    } else if (std > 18) {
      setSignalStatus('warn', 'signal: lots of motion, hold still');
    } else {
      setSignalStatus('ok', 'signal: ok');
    }

    // Peak detection and HR update
    detectPeaks();
    estimateHR();

    // Plot
    drawPlot();

    rafId = requestAnimationFrame(loop);
  }

  // UI wiring
  startBtn.addEventListener('click', start);
  stopBtn.addEventListener('click', stop);

  let torchOn = false;
  torchBtn.addEventListener('click', async () => {
    torchOn = !torchOn;
    const ok = await tryTorch(torchOn);
    if (!ok) {
      torchOn = false;
      alert('Torch not supported on this device/browser. That is normal, especially on iPhone. Continue without torch.');
    } else {
      torchBtn.textContent = torchOn ? 'Torch on' : 'Try torch';
    }
  });

})();
</script>
</body>
</html>

